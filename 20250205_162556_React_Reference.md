# React Reference

A comprehensive guide to common React patterns and templates with detailed explanations.

## Testing Boilerplate
// Basic test setup using React Testing Library and Vitest
// Demonstrates component rendering and assertion pattern
```javascript
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { describe, it, expect, vi } from 'vitest'

describe('Component', () => {
  // Test case verifies component renders with expected elements
  it('renders correctly', () => {
    render(<Component />)
    expect(screen.getByRole('button')).toBeInTheDocument()
  })
})
```

## useEffect
### Overview
- A React Hook for managing side effects in functional components
- Side effects are operations that can't be done during rendering:
  - Data fetching
  - Subscriptions
  - DOM manipulations
  - Logging
  - Timer operations
  - Third-party library integrations

### Syntax
```javascript
// effectFunction: Contains the code to run
// dependencyArray: Controls when effect runs (optional)
useEffect(effectFunction, dependencyArray)
```

### Dependency Array Behavior
```javascript
// Empty array: Runs once after initial render
// Similar to componentDidMount in class components
useEffect(() => {
  // Effect code
  console.log('Component mounted');
}, []);

// With dependencies: Runs when count changes
// Similar to componentDidUpdate with specific props
useEffect(() => {
  // Effect code
  console.log('Count changed to:', count);
}, [count]);

// No dependency array: Runs after every render
// Use with caution - can cause performance issues
useEffect(() => {
  // Effect code
  console.log('Component updated');
});

// With cleanup: Prevents memory leaks
// Similar to componentWillUnmount
useEffect(() => {
  const subscription = api.subscribe();
  // Cleanup function runs before unmount and before re-running effect
  return () => {
    subscription.unsubscribe();
  };
}, []);
```

## Custom Hook Pattern
// Template for creating reusable hooks with TypeScript
// Demonstrates state management and effect cleanup
```javascript
import { useState, useEffect } from 'react'

interface UseCustomHookProps {
  initialValue: string
}

export const useCustomHook = ({ initialValue }: UseCustomHookProps) => {
  // State management using array destructuring
  const [value, setValue] = useState(initialValue)
  
  useEffect(() => {
    // Setup effect (e.g., subscriptions, event listeners)
    const handler = () => {
      // Effect logic
    }
    
    // Cleanup function
    return () => {
      // Cleanup logic (e.g., unsubscribe, remove listeners)
    }
  }, []) // Empty dependency array = run once

  return { value, setValue }
}
```

## RTK Query API Integration
// Redux Toolkit Query setup for API calls
// Provides automatic caching and request lifecycle management
```javascript
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

export const api = createApi({
  // Unique key for Redux store
  reducerPath: 'api',
  // Base configuration for all requests
  baseQuery: fetchBaseQuery({ 
    baseUrl: '/api',
    credentials: 'include', // Includes cookies in requests
  }),
  // Define API endpoints
  endpoints: (builder) => ({
    getData: builder.query<ResponseType, void>({
      query: () => 'data', // Appended to baseUrl
    }),
  }),
})

// Export hooks for use in components
export const { useGetDataQuery } = api
```

## Context with useReducer
// Advanced state management pattern combining Context and useReducer
// Provides global state with type-safe updates
```javascript
import { createContext, useContext, useReducer, ReactNode } from 'react'

// Define state structure
interface AppState {
  user: User | null
  theme: 'light' | 'dark'
  settings: Record<string, unknown>
}

// Define possible actions
type Action = 
  | { type: 'SET_USER'; payload: User }
  | { type: 'TOGGLE_THEME' }

// Create context with TypeScript types
const AppContext = createContext<{
  state: AppState
  dispatch: React.Dispatch<Action>
} | undefined>(undefined)

// Initial state
const initialState: AppState = {
  user: null,
  theme: 'light',
  settings: {}
}

// Reducer function handles state updates
function reducer(state: AppState, action: Action): AppState {
  switch (action.type) {
    case 'SET_USER':
      return { ...state, user: action.payload }
    case 'TOGGLE_THEME':
      return { ...state, theme: state.theme === 'light' ? 'dark' : 'light' }
    default:
      return state
  }
}

// Provider component wraps app with context
export function AppProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(reducer, initialState)
  return (
    <AppContext.Provider value={{ state, dispatch }}>
      {children}
    </AppContext.Provider>
  )
}

// Custom hook for using context
export function useApp() {
  const context = useContext(AppContext)
  if (!context) throw new Error('useApp must be used within AppProvider')
  return context
}
```

## Compound Components
// Pattern for creating flexible, composable components
// Example shows tabs implementation with shared state
```javascript
import { createContext, useState, useContext, ReactNode } from 'react'

// Define context type
interface TabsContextType {
  activeTab: string
  setActiveTab: (tab: string) => void
}

const TabsContext = createContext<TabsContextType | undefined>(undefined)

// Main Tabs component props
interface TabsProps {
  children: ReactNode
  defaultTab: string
}

// Parent Tabs component
export function Tabs({ children, defaultTab }: TabsProps) {
  const [activeTab, setActiveTab] = useState(defaultTab)
  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  )
}

// Header subcomponent
Tabs.Header = function TabHeader({ children }: { children: ReactNode }) {
  return <div className="tabs-header">{children}</div>
}

// Panel props
interface TabPanelProps {
  children: ReactNode
  tabId: string
}

// Panel subcomponent
Tabs.Panel = function TabPanel({ children, tabId }: TabPanelProps) {
  const context = useContext(TabsContext)
  if (!context) throw new Error('TabPanel must be used within Tabs')
  if (context.activeTab !== tabId) return null
  return <div className="tab-panel">{children}</div>
}
```

## Custom Store Hook
// Simple state management solution using hooks
// Alternative to Redux for simpler applications
```javascript
import { useState, useCallback } from 'react'

// Define store structure
interface Store<T> {
  state: T
  actions: {
    updateUser: (user: User) => void
    updateSettings: (settings: Settings) => void
    reset: () => void
  }
}

// Custom store hook with generic type
export function useStore<T extends object>(initialState: T): Store<T> {
  const [state, setState] = useState(initialState)

  // Memoized actions to prevent unnecessary rerenders
  const actions = {
    updateUser: useCallback((user: User) => {
      setState(prev => ({ ...prev, user }))
    }, []),
    updateSettings: useCallback((settings: Settings) => {
      setState(prev => ({ ...prev, settings }))
    }, []),
    reset: useCallback(() => {
      setState(initialState)
    }, [initialState])
  }

  return { state, actions }
}
```