# React Reference

A comprehensive guide to common React patterns and templates with detailed explanations.

//# region Testing Boilerplate

## Testing Boilerplate

// Basic test setup using React Testing Library and Vitest
// Demonstrates component rendering and assertion pattern

```javascript
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { describe, it, expect, vi } from "vitest";

describe("Component", () => {
  // Test case verifies component renders with expected elements
  it("renders correctly", () => {
    render(<Component />);
    expect(screen.getByRole("button")).toBeInTheDocument();
  });
});
```

//#endregion

//#region useEffect

## useEffect

### Overview

- A React Hook for managing side effects in functional components
- Side effects are operations that can't be done during rendering:
  - Data fetching
  - Subscriptions
  - DOM manipulations
  - Logging
  - Timer operations
  - Third-party library integrations

### Syntax

```javascript
// effectFunction: Contains the code to run
// dependencyArray: Controls when effect runs (optional)
useEffect(effectFunction, dependencyArray);
```

### Dependency Array Behavior

```javascript
// Empty array: Runs once after initial render
// Similar to componentDidMount in class components
useEffect(() => {
  // Effect code
  console.log("Component mounted");
}, []);

// With dependencies: Runs when count changes
// Similar to componentDidUpdate with specific props
useEffect(() => {
  // Effect code
  console.log("Count changed to:", count);
}, [count]);

// No dependency array: Runs after every render
// Use with caution - can cause performance issues
useEffect(() => {
  // Effect code
  console.log("Component updated");
});

// With cleanup: Prevents memory leaks
// Similar to componentWillUnmount
useEffect(() => {
  const timer = setInterval(() => {
    setTimeValue((prev) => prev - 1);
  }, 1000);

  // Cleanup prevents memory leaks
  return () => clearInterval(timer);
}, []);
```

//#endregion

//#region Custom Hook Patterns

## Custom Hook Patterns

### useForm

```javascript
const useForm = (initialValues) => {
  const [values, setValues] = useState(initialValues);

  const handleChange = (e) => {
    setValues({
      ...values,
      [e.target.name]: e.target.value,
    });
  };

  return [values, handleChange];
};
```

### useFetch

```javascript
const useFetch = (url) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch(url);
        const json = await response.json();
        setData(json);
        setLoading(false);
      } catch (err) {
        setError(err);
        setLoading(false);
      }
    };
    fetchData();
  }, [url]);

  return { data, loading, error };
};
```

### useLocalStorage

```javascript
const useLocalStorage = (key, initialValue) => {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  const setValue = (value) => {
    try {
      setStoredValue(value);
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.log(error);
    }
  };

  return [storedValue, setValue];
};
```

### useTimer

```javascript
const useTimer = (initialTime) => {
  const [time, setTime] = useState(initialTime);
  const [isRunning, setIsRunning] = useState(false);
  const timerRef = useRef(null);

  useEffect(() => {
    if (isRunning && time > 0) {
      timerRef.current = setInterval(() => {
        setTime((prev) => prev - 1);
      }, 1000);
    }

    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
      }
    };
  }, [isRunning, time]);

  const start = () => setIsRunning(true);
  const stop = () => setIsRunning(false);
  const reset = () => setTime(initialTime);

  return { time, isRunning, start, stop, reset };
};
```

### useDebounce

```javascript
const useDebounce = (value, delay) => {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);

  return debouncedValue;
};
```

//#endregion

//#region Custom Hook Template

## Custom Hook Template

```javascript
import { useState, useEffect } from "react";

interface UseCustomHookProps {
  initialValue: string;
}

export const useCustomHook = ({ initialValue }: UseCustomHookProps) => {
  // State management using array destructuring
  const [value, setValue] = useState(initialValue);

  useEffect(() => {
    // Setup effect (e.g., subscriptions, event listeners)
    const handler = () => {
      // Effect logic
    };

    // Cleanup function
    return () => {
      // Cleanup logic (e.g., unsubscribe, remove listeners)
    };
  }, []); // Empty dependency array = run once

  return { value, setValue };
};
```

//#endregion

//#region RTK Query API Integration

## RTK Query API Integration

// Redux Toolkit Query setup for API calls
// Provides automatic caching and request lifecycle management

```javascript
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

export const api = createApi({
  // Unique key for Redux store
  reducerPath: 'api',
  // Base configuration for all requests
  baseQuery: fetchBaseQuery({
    baseUrl: '/api',
    credentials: 'include', // Includes cookies in requests
  }),
  // Define API endpoints
  endpoints: (builder) => ({
    getData: builder.query<ResponseType, void>({
      query: () => 'data', // Appended to baseUrl
    }),
  }),
})

// Export hooks for use in components
export const { useGetDataQuery } = api
```

//#endregion

//#region Context with useReducer

## Context with useReducer

// Advanced state management pattern combining Context and useReducer
// Provides global state with type-safe updates

```javascript
import { createContext, useContext, useReducer, ReactNode } from 'react'

// Define state structure
interface AppState {
  user: User | null
  theme: 'light' | 'dark'
  settings: Record<string, unknown>
}

// Define possible actions
type Action =
  | { type: 'SET_USER'; payload: User }
  | { type: 'TOGGLE_THEME' }

// Create context with TypeScript types
const AppContext = createContext<{
  state: AppState
  dispatch: React.Dispatch<Action>
} | undefined>(undefined)

// Initial state
const initialState: AppState = {
  user: null,
  theme: 'light',
  settings: {}
}

// Reducer function handles state updates
function reducer(state: AppState, action: Action): AppState {
  switch (action.type) {
    case 'SET_USER':
      return { ...state, user: action.payload }
    case 'TOGGLE_THEME':
      return { ...state, theme: state.theme === 'light' ? 'dark' : 'light' }
    default:
      return state
  }
}

// Provider component wraps app with context
export function AppProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(reducer, initialState)
  return (
    <AppContext.Provider value={{ state, dispatch }}>
      {children}
    </AppContext.Provider>
  )
}

// Custom hook for using context
export function useApp() {
  const context = useContext(AppContext)
  if (!context) throw new Error('useApp must be used within AppProvider')
  return context
}
```

//#endregion

//#region Compound Components

## Compound Components

// Pattern for creating flexible, composable components
// Example shows tabs implementation with shared state

```javascript
import { createContext, useState, useContext, ReactNode } from 'react'

// Define context type
interface TabsContextType {
  activeTab: string
  setActiveTab: (tab: string) => void
}

const TabsContext = createContext<TabsContextType | undefined>(undefined)

// Main Tabs component props
interface TabsProps {
  children: ReactNode
  defaultTab: string
}

// Parent Tabs component
export function Tabs({ children, defaultTab }: TabsProps) {
  const [activeTab, setActiveTab] = useState(defaultTab)
  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  )
}

// Header subcomponent
Tabs.Header = function TabHeader({ children }: { children: ReactNode }) {
  return <div className="tabs-header">{children}</div>
}

// Panel props
interface TabPanelProps {
  children: ReactNode
  tabId: string
}

// Panel subcomponent
Tabs.Panel = function TabPanel({ children, tabId }: TabPanelProps) {
  const context = useContext(TabsContext)
  if (!context) throw new Error('TabPanel must be used within Tabs')
  if (context.activeTab !== tabId) return null
  return <div className="tab-panel">{children}</div>
}
```

//#endregion

//#region Custom Store Hook

## Custom Store Hook

// Simple state management solution using hooks
// Alternative to Redux for simpler applications

```javascript
import { useState, useCallback } from 'react'

// Define store structure
interface Store<T> {
  state: T
  actions: {
    updateUser: (user: User) => void
    updateSettings: (settings: Settings) => void
    reset: () => void
  }
}

// Custom store hook with generic type
export function useStore<T extends object>(initialState: T): Store<T> {
  const [state, setState] = useState(initialState)

  // Memoized actions to prevent unnecessary rerenders
  const actions = {
    updateUser: useCallback((user: User) => {
      setState(prev => ({ ...prev, user }))
    }, []),
    updateSettings: useCallback((settings: Settings) => {
      setState(prev => ({ ...prev, settings }))
    }, []),
    reset: useCallback(() => {
      setState(initialState)
    }, [initialState])
  }

  return { state, actions }
}
```

//#endregion
